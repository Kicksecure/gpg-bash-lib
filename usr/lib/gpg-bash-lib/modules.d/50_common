#!/bin/bash

## This file is part of Whonix.
## Copyright (C) 2012 - 2014 Patrick Schleizer <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

gpg_bash_lib_function_error_handler() {
   gpg_bash_lib_output_error_handler_last_failed_exit_code="$?"
   gpg_bash_lib_output_error_handler_message="$0 script bug
Please report this bug!
BASH_COMMAND: $BASH_COMMAND
exit_code: $gpg_bash_lib_output_error_handler_last_failed_exit_code"
   gpg_bash_lib_output_failure_status="true"
   gpg_bash_lib_function_diagnostic_message
   gpg_bash_lib_output_error_handler_message="\
$gpg_bash_lib_output_error_handler_message
-----
gpg_bash_lib_output_diagnostic_message:
$gpg_bash_lib_output_diagnostic_message"
   if [ ! "$gpg_bash_lib_input_error_handler_extra" = "" ]; then
      eval $gpg_bash_lib_input_error_handler_extra
   fi
   exit 1
}

gpg_bash_lib_function_init() {
   [ -n "$gpg_bash_lib_input_temp_folder" ] || gpg_bash_lib_input_temp_folder="$(mktemp --directory)"
   gpg_bash_lib_output_failure_status="false"
   gpg_bash_lib_output_diagnostic_message=""
   [ -n "$gpg_bash_lib_internal_gpg_verify_status_fd_file" ] || gpg_bash_lib_internal_gpg_verify_status_fd_file="$gpg_bash_lib_input_temp_folder/gpg_bash_lib_internal_gpg_verify_status_fd_file"
   [ -n "$gpg_bash_lib_internal_gpg_verify_output_file" ] || gpg_bash_lib_internal_gpg_verify_output_file="$gpg_bash_lib_input_temp_folder/gpg_bash_lib_internal_gpg_verify_output_file"
   gpg_bash_lib_output_gpg_import_output=""
   gpg_bash_lib_output_gpg_verify_exit_code=""
   gpg_bash_lib_output_gpg_verify_output=""
   gpg_bash_lib_output_gpg_verify_status_fd_output=""
   gpg_bash_lib_output_signed_on_unixtime=""
   gpg_bash_lib_output_signed_on_date=""
   gpg_bash_lib_output_file_name_tampering=""
   unset gpg_bash_lib_output_notation
   declare -A -g gpg_bash_lib_output_notation
   gpg_bash_lib_output_slow_clock_lenient_up_to_pretty_output=""
   gpg_bash_lib_output_goodsig_status="false"
   gpg_bash_lib_output_validsig_status="false"
   gpg_bash_lib_output_fingerprint_in_hex=""
   gpg_bash_lib_output_current_unixtime=""
   gpg_bash_lib_output_current_time=""
   gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime=""
   gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime_pretty=""
   gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime=""
   gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime_pretty=""
   gpg_bash_lib_output_in_future_in_seconds=""
   gpg_bash_lib_output_in_future_pretty_output=""
   gpg_bash_lib_output_freshness_status=""
   gpg_bash_lib_output_freshness_detail=""
   gpg_bash_lib_output_freshness_msg=""
   gpg_bash_lib_output_maximum_age_pretty_output=""
   gpg_bash_lib_output_alright_status=""

   ## Sanity tests.
   command -v date >/dev/null
   command -v gpg >/dev/null
   command -v mktemp >/dev/null

   rm --recursive --force "$gpg_bash_lib_input_temp_folder"
   mkdir --parents "$gpg_bash_lib_input_temp_folder"
   chmod --recursive 700 "$gpg_bash_lib_input_temp_folder"
   test -d "$gpg_bash_lib_input_temp_folder"
}

gpg_bash_lib_function_alright_maybe() {
   if [ "$gpg_bash_lib_output_alright_status" = "false" ]; then
      return 0
   fi
   if [ ! "$gpg_bash_lib_output_goodsig_status" = "true" ]; then
     gpg_bash_lib_output_alright_status="false"
     return 0
   fi
   if [ ! "$gpg_bash_lib_output_validsig_status" = "true" ]; then
     gpg_bash_lib_output_alright_status="false"
     return 0
   fi
   gpg_bash_lib_output_alright_status="true"
}

gpg_bash_lib_function_import_keys_to_temp_dir() {
   test -d "$gpg_bash_lib_input_key_import_dir"

   ## TODO: Only shopt when not already.
   shopt -s nullglob dotglob

   local gpg_bash_lib_internal_key

   for gpg_bash_lib_internal_key in "$gpg_bash_lib_input_key_import_dir/"*; do
      local gpg_bash_lib_internal_key_file_name
      gpg_bash_lib_internal_key_file_name="$(basename "$gpg_bash_lib_internal_key")"
      if [ "$gpg_bash_lib_internal_key_file_name" = "placeholder" ]; then
         continue
      fi
      ## Using --ignore-time-conflict, because otherwise
      ## check "gpg --import"'s exit code would exit with a non-zero return code
      ## if key import failed (such as code 1, see example below).
      ## Example:
      ##     gpg: key 63FEE659 was created 119604046 seconds in the future (time warp or clock problem)
      ## Therefore we ignore time conflicts, because a clock sanity check will be done later.
      gpg_bash_lib_output_gpg_import_output="$( \
            gpg \
               --no-options \
               --ignore-time-conflict \
               --homedir "$gpg_bash_lib_input_temp_folder" \
               --import "$gpg_bash_lib_internal_key" \
               2>&1 \
         )"
   done

   ## TODO: Only undo, if we enabled this beforehand.
   shopt -u nullglob dotglob
}

gpg_bash_lib_function_verify() {
   rm --force "$gpg_bash_lib_internal_gpg_verify_status_fd_file"

   test -f "$gpg_bash_lib_input_data_file"
   test -f "$gpg_bash_lib_input_sig_file"

   [ -n "$gpg_bash_lib_input_verify_timeout_after" ] || gpg_bash_lib_input_verify_timeout_after="10"
   [ -n "$gpg_bash_lib_input_verify_kill_after" ] || gpg_bash_lib_input_verify_kill_after="10"
   ## Up to 30 minutes lenient about slow clocks by default.
   [ -n "$gpg_bash_lib_input_slow_clock_lenient_up_to_seconds" ] || gpg_bash_lib_input_slow_clock_lenient_up_to_seconds="$(( 30 * 60 ))"
   gpg_bash_lib_output_slow_clock_lenient_up_to_pretty_output="$(gpg_bash_lib_function_displaytime "$gpg_bash_lib_input_slow_clock_lenient_up_to_seconds")"

   ## One month has 2592000 seconds.
   ## (60 [seconds] * 60 [minutes] * 24 [hours] * 30 [days])
   gpg_bash_lib_internal_month_has_seconds="2592000"
   [ -n "$gpg_bash_lib_input_maximum_age_in_seconds" ] || gpg_bash_lib_input_maximum_age_in_seconds="$gpg_bash_lib_internal_month_has_seconds"
   gpg_bash_lib_output_maximum_age_pretty_output="$(gpg_bash_lib_function_displaytime "$gpg_bash_lib_input_maximum_age_in_seconds")"

   local gpg_bash_lib_internal_gpg_verify_pid

   timeout \
      --kill-after="$gpg_bash_lib_input_verify_kill_after" "$gpg_bash_lib_input_verify_timeout_after" \
         gpg \
            --no-options \
            --ignore-time-conflict \
            --status-file "$gpg_bash_lib_internal_gpg_verify_status_fd_file" \
            --homedir "$gpg_bash_lib_input_temp_folder" \
            --verify-options show-notations \
            --verify "$gpg_bash_lib_input_sig_file" \
            "$gpg_bash_lib_input_data_file" \
            > "$gpg_bash_lib_internal_gpg_verify_output_file" \
            2>&1 \
            &

   gpg_bash_lib_internal_gpg_verify_pid="$!"
   if wait "$gpg_bash_lib_internal_gpg_verify_pid" ; then
      gpg_bash_lib_output_gpg_verify_exit_code="0"
   else
      gpg_bash_lib_output_gpg_verify_exit_code="$?"
   fi

   ## `timeout` returns:
   ## - 124 if sigterm was sufficient
   ## - 137 if needed to use kill.

   gpg_bash_lib_output_gpg_verify_output="$(cat "$gpg_bash_lib_internal_gpg_verify_output_file")" || true
}

gpg_bash_lib_function_parse_status_file() {
   test -f "$gpg_bash_lib_internal_gpg_verify_status_fd_file"

   gpg_bash_lib_output_gpg_verify_status_fd_output="$(cat "$gpg_bash_lib_internal_gpg_verify_status_fd_file")"

   ## Example gpg_bash_lib_internal_gpg_verify_status_fd_file:
   ## [GNUPG:] SIG_ID xl52dwvbkcu7YkXw6Zv/PUhexUk 2015-01-15 1421344751
   ## [GNUPG:] GOODSIG CB8D50BB77BB3C48 Patrick Schleizer <adrelanos@riseup.net>
   ## [GNUPG:] NOTATION_NAME issuer-fpr@notations.openpgp.fifthhorseman.net
   ## [GNUPG:] NOTATION_DATA 6E979B28A6F37C43BE30AFA1CB8D50BB77BB3C48
   ## [GNUPG:] NOTATION_NAME file@name
   ## [GNUPG:] NOTATION_DATA a
   ## [GNUPG:] VALIDSIG 6E979B28A6F37C43BE30AFA1CB8D50BB77BB3C48 2015-01-15 1421344751 0 4 0 1 10 00 916B8D99C38EAF5E8ADC7A2A8D66066A2EEACCDA
   ## [GNUPG:] TRUST_ULTIMATE

   ## Another gpg_bash_lib_internal_gpg_verify_status_fd_file::
   ## [GNUPG:] ERRSIG 9C131AD3713AAEEF 1 10 00 1381635738 9
   ## [GNUPG:] NO_PUBKEY 9C131AD3713AAEEF

   ## Another gpg_bash_lib_internal_gpg_verify_status_fd_file::
   ## [GNUPG:] KEYEXPIRED 1607731200
   ## [GNUPG:] SIGEXPIRED deprecated-use-keyexpired-instead
   ## [GNUPG:] KEYEXPIRED 1607731200
   ## [GNUPG:] SIGEXPIRED deprecated-use-keyexpired-instead
   ## [GNUPG:] KEYEXPIRED 1607731200
   ## [GNUPG:] SIGEXPIRED deprecated-use-keyexpired-instead
   ## [GNUPG:] SIG_ID Tk/VeQa7RTYC/8JwlICrAFEi5es 2015-01-27 1422383418
   ## [GNUPG:] KEYEXPIRED 1607731200
   ## [GNUPG:] SIGEXPIRED deprecated-use-keyexpired-instead
   ## [GNUPG:] KEYEXPIRED 1607731200
   ## [GNUPG:] SIGEXPIRED deprecated-use-keyexpired-instead
   ## [GNUPG:] EXPKEYSIG 8D6648AA636E1951 auto generated test key for unit test <unit@test.key>
   ## [GNUPG:] NOTATION_NAME file@name
   ## [GNUPG:] NOTATION_DATA test-file
   ## [GNUPG:] KEYEXPIRED 1607731200
   ## [GNUPG:] SIGEXPIRED deprecated-use-keyexpired-instead
   ## [GNUPG:] KEYEXPIRED 1607731200
   ## [GNUPG:] SIGEXPIRED deprecated-use-keyexpired-instead
   ## [GNUPG:] VALIDSIG 8A2EEB750FD937F70828D5628D6648AA636E1951 2015-01-27 1422383418 0 4 0 1 2 00 8BC6714D5654D0813BBAB42F818A9682FE742EFD'

   ## KEYEXPIRED -> not useful as per gnupg documentation DETAILS file
   ## SIGEXPIRED -> deprecated as per gnupg documentation DETAILS file

   local gpg_bash_lib_internal_line
   while read -r -d $'\n' gpg_bash_lib_internal_line; do
      true "gpg_bash_lib_internal_line: $gpg_bash_lib_internal_line"
      local one two three four five
      read -r one two three four five _ <<< "$gpg_bash_lib_internal_line"
      true "one: $one | two: $two | three: $three | four: $four | five: $five"
      if [ "$two" = "GOODSIG" ]; then
         gpg_bash_lib_output_goodsig_status="true"
      fi
      if [ "$two" = "VALIDSIG" ]; then
         gpg_bash_lib_output_validsig_status="true"
         gpg_bash_lib_output_fingerprint_in_hex="$three"
         gpg_bash_lib_output_signed_on_unixtime="$five"
      fi
      if [ "$two" = "NOTATION_NAME" ]; then
         gpg_bash_lib_internal_notation_name="$three"
      fi
      if [ "$two" = "NOTATION_DATA" ]; then
         gpg_bash_lib_output_notation[$gpg_bash_lib_internal_notation_name]="$three"
      fi
   done < "$gpg_bash_lib_internal_gpg_verify_status_fd_file"

   if [ "$gpg_bash_lib_output_signed_on_unixtime" = "" ]; then
      error "gpg_bash_lib_output_signed_on_unixtime is empty!"
   fi

   ## Thanks to:
   ## http://mywiki.wooledge.org/BashFAQ/054
   if [[ "$gpg_bash_lib_output_signed_on_unixtime" != *[!0-9]* ]]; then
      true "'$gpg_bash_lib_output_signed_on_unixtime' is strictly numeric."
   else
      error "gpg_bash_lib_output_signed_on_unixtime is NOT strictly numeric, it is: $gpg_bash_lib_output_signed_on_unixtime"
   fi

   gpg_bash_lib_output_signed_on_date="$(date --utc --date "@$gpg_bash_lib_output_signed_on_unixtime" "+%B %d %H:%M:%S UTC %Y")"

   if [ "${gpg_bash_lib_output_notation["file@name"]}" = "" ]; then
      true "\${gpg_bash_lib_output_notation["file@name"]} is unset."
      gpg_bash_lib_output_file_name_tampering="missing"
      if [ "$gpg_bash_lib_input_file_name_enforce" = "true" ]; then
         gpg_bash_lib_output_alright_status="false"
      fi
   else
      true "\${gpg_bash_lib_output_notation["file@name"]} is set to: ${gpg_bash_lib_output_notation["file@name"]}"
      if [ "$(basename "$gpg_bash_lib_input_data_file")" = "${gpg_bash_lib_output_notation["file@name"]}" ]; then
         gpg_bash_lib_output_file_name_tampering="false"
      else
         gpg_bash_lib_output_file_name_tampering="true"
         if [ "$gpg_bash_lib_input_file_name_enforce" = "true" ]; then
            gpg_bash_lib_output_alright_status="false"
         fi
      fi
   fi
}

gpg_bash_lib_function_process() {
   gpg_bash_lib_output_current_unixtime="$(date +%s)"
   gpg_bash_lib_output_current_time="$(date --utc "+%B %d %H:%M:%S UTC %Y")"

   gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime="$(( $gpg_bash_lib_output_signed_on_unixtime - $gpg_bash_lib_output_current_unixtime ))"
   gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime_pretty="$(gpg_bash_lib_function_displaytime "$gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime")"

   gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime="$(( $gpg_bash_lib_output_current_unixtime - $gpg_bash_lib_output_signed_on_unixtime ))"
   gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime_pretty="$(gpg_bash_lib_function_displaytime "$gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime")"

   gpg_bash_lib_output_in_future_in_seconds="$(( $gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime - $gpg_bash_lib_input_maximum_age_in_seconds ))"
   gpg_bash_lib_output_in_future_pretty_output="$(gpg_bash_lib_function_displaytime "$gpg_bash_lib_output_in_future_in_seconds")"

   if [ "$gpg_bash_lib_output_current_unixtime" -le "$gpg_bash_lib_output_signed_on_unixtime" ]; then
      if [ "$gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime" -lt "$gpg_bash_lib_input_slow_clock_lenient_up_to_seconds" ]; then
         gpg_bash_lib_output_freshness_status="true"
         gpg_bash_lib_output_freshness_detail="lenient"
         gpg_bash_lib_output_freshness_msg="\
- Freshness: Signature is not yet valid.
- valid-max: Signatures are valid up to $gpg_bash_lib_output_maximum_age_pretty_output.
- Signature Creation Date: $gpg_bash_lib_output_signed_on_date
- Current System Date    : $gpg_bash_lib_output_current_time
- Local System Clock: Your clock might be slow. (Could be at least $gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime_pretty slow.)
- Relative Signature Creation Time: According to your system clock, signature was created $gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime_pretty before current time.
- Leniency: Ignoring this, because it still is within range.
Valid up to gpg_bash_lib_output_slow_clock_lenient_up_to_pretty_output $gpg_bash_lib_output_slow_clock_lenient_up_to_pretty_output before."
         gpg_bash_lib_function_alright_maybe
         return 0
      else
         gpg_bash_lib_output_freshness_status="false"
         gpg_bash_lib_output_freshness_detail="slow"
         gpg_bash_lib_output_freshness_msg="\
- Freshness: Signature is not yet valid.
- valid-max: Signatures are valid up to $gpg_bash_lib_output_maximum_age_pretty_output.
- Signature Creation Date: $gpg_bash_lib_output_signed_on_date
- Current System Date    : $gpg_bash_lib_output_current_time
- Local System Clock: Your clock might be slow. (Could be at least $gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime_pretty slow.)
- Relative Signature Creation Time: According to your system clock, signature was created $gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime_pretty before current time."
         gpg_bash_lib_output_alright_status="false"
         return 0
      fi
   elif [ "$gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime" -ge "$gpg_bash_lib_input_maximum_age_in_seconds" ]; then
      gpg_bash_lib_output_freshness_status="false"
      gpg_bash_lib_output_freshness_detail="outdated"
      gpg_bash_lib_output_freshness_msg="\
- Freshness: Signature is no longer valid (outdated).
- valid-max: Signatures are valid up to $gpg_bash_lib_output_maximum_age_pretty_output.
- Signature Creation Date: $gpg_bash_lib_output_signed_on_date
- Current System Date    : $gpg_bash_lib_output_current_time
- Local System Clock: Your clock might be fast. (Could be at least $gpg_bash_lib_output_in_future_pretty_output fast.)
- Relative Signature Creation Time: According to your system clock, signature was created $gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime_pretty ago.
- Extra: It might have been forgotten to refresh the signature (invalid since $gpg_bash_lib_output_in_future_pretty_output)."
      gpg_bash_lib_output_alright_status="false"
      return 0
   else
      gpg_bash_lib_output_freshness_status="true"
      gpg_bash_lib_output_freshness_detail="current"
      gpg_bash_lib_output_freshness_msg="\
- Freshness: Signature is current.
- valid-max: Signatures are valid up to $gpg_bash_lib_output_maximum_age_pretty_output.
- Signature Creation Date: $gpg_bash_lib_output_signed_on_date
- Current System Date    : $gpg_bash_lib_output_current_time
- Local System Clock: Your clock seems okay.
- Relative Signature Creation Time: According to your system clock, signature was created $gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime_pretty ago."
      gpg_bash_lib_function_alright_maybe
      return 0
   fi
}

gpg_bash_lib_function_diagnostic_message() {
   gpg_bash_lib_output_diagnostic_message="\
gpg_bash_lib_internal_gpg_verify_status_fd_file: $gpg_bash_lib_internal_gpg_verify_status_fd_file
gpg_bash_lib_internal_gpg_verify_output_file: $gpg_bash_lib_internal_gpg_verify_output_file
gpg_bash_lib_output_gpg_import_output:
$gpg_bash_lib_output_gpg_import_output
gpg_bash_lib_output_gpg_verify_output:
$gpg_bash_lib_output_gpg_verify_output
gpg_bash_lib_output_gpg_verify_status_fd_output:
$gpg_bash_lib_output_gpg_verify_status_fd_output"
}

gpg_bash_lib_function_cleanup() {
   if [ "$gpg_bash_lib_input_cleanup" = "true" ]; then
      if [ -e "$gpg_bash_lib_internal_gpg_verify_status_fd_file" ]; then
         rm --force "$gpg_bash_lib_internal_gpg_verify_status_fd_file"
      fi
      if [ -d "$gpg_bash_lib_input_temp_folder" ]; then
         rm --force --recursive "$gpg_bash_lib_input_temp_folder"
      fi
   fi
}

gpg_bash_lib_function_main_verify() {
   gpg_bash_lib_function_cleanup
   gpg_bash_lib_function_init
   gpg_bash_lib_function_import_keys_to_temp_dir
   gpg_bash_lib_function_verify
   if [ ! "$gpg_bash_lib_output_gpg_verify_exit_code" = "0" ]; then
      gpg_bash_lib_function_diagnostic_message
      return 0
   fi
   gpg_bash_lib_function_parse_status_file
   gpg_bash_lib_function_process
   gpg_bash_lib_function_diagnostic_message
   gpg_bash_lib_function_cleanup
}
